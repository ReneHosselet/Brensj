{"version":3,"file":"VariantMaterialLoaderPlugin.js","sourceRoot":"","sources":["../../../src/three-components/gltf-instance/VariantMaterialLoaderPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the 'License');\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an 'AS IS' BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * Materials variants extension\r\n *\r\n * Specification:\r\n * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\r\n */\r\n\r\n/**\r\n * The code in this file is based on\r\n * https://github.com/takahirox/three-gltf-extensions/tree/main/loaders/KHR_materials_variants\r\n */\r\n\r\nimport {Material, Mesh, Object3D} from 'three';\r\nimport {GLTF, GLTFLoaderPlugin, GLTFParser} from 'three/examples/jsm/loaders/GLTFLoader.js';\r\n\r\n/**\r\n * KHR_materials_variants specification allows duplicated variant names\r\n * but it makes handling the extension complex.\r\n * We ensure tha names and make it easier.\r\n * If you want to export the extension with the original names\r\n * you are recommended to write GLTFExporter plugin to restore the names.\r\n *\r\n * @param variantNames {Array<string>}\r\n * @return {Array<string>}\r\n */\r\nconst ensureUniqueNames = (variantNames: string[]) => {\r\n  const uniqueNames = [];\r\n  const knownNames = new Set<string>();\r\n\r\n  for (const name of variantNames) {\r\n    let uniqueName = name;\r\n    let suffix = 0;\r\n    // @TODO: An easy solution.\r\n    //        O(N^2) in the worst scenario where N is variantNames.length.\r\n    //        Fix me if needed.\r\n    while (knownNames.has(uniqueName)) {\r\n      uniqueName = name + '.' + (++suffix);\r\n    }\r\n    knownNames.add(uniqueName);\r\n    uniqueNames.push(uniqueName);\r\n  }\r\n\r\n  return uniqueNames;\r\n};\r\n\r\n/**\r\n * Convert mappings array to table object to make handling the extension easier.\r\n *\r\n * @param\r\n *     extensionDef {glTF.meshes[n].primitive.extensions.KHR_materials_variants}\r\n * @param variantNames {Array<string>} Required to be unique names\r\n * @return {Map}\r\n */\r\nconst mappingsArrayToTable = (extensionDef: any, variantNames: string[]) => {\r\n  const table =\r\n      new Map<string, {material: Material | null, gltfMaterialIndex: number}>();\r\n  for (const mapping of extensionDef.mappings) {\r\n    for (const variant of mapping.variants) {\r\n      table.set(\r\n          variantNames[variant],\r\n          {material: null, gltfMaterialIndex: mapping.material});\r\n    }\r\n  }\r\n  return table;\r\n};\r\n\r\n/**\r\n * @param object {THREE.Object3D}\r\n * @return {boolean}\r\n */\r\nconst compatibleObject = (object: Object3D) => {\r\n  return 'material' in object &&  // easier than (!object.isMesh &&\r\n                                  // !object.isLine && !object.isPoints)\r\n      object!.userData &&         // just in case\r\n      object!.userData.variantMaterials;\r\n};\r\n\r\nexport default class GLTFMaterialsVariantsExtension implements\r\n    GLTFLoaderPlugin {\r\n  parser: GLTFParser;\r\n  name: string;\r\n\r\n  constructor(parser: GLTFParser) {\r\n    this.parser = parser;\r\n    this.name = 'KHR_materials_variants';\r\n  }\r\n\r\n  // Note that the following properties will be overridden even if they are\r\n  // pre-defined\r\n  // - gltf.userData.variants\r\n  // - mesh.userData.variantMaterials\r\n  afterRoot(gltf: GLTF) {\r\n    const parser = this.parser;\r\n    const json = parser.json;\r\n\r\n    if (json.extensions === undefined ||\r\n        json.extensions[this.name] === undefined) {\r\n      return null;\r\n    }\r\n\r\n    const extensionDef = json.extensions[this.name];\r\n    const variantsDef = extensionDef.variants || [];\r\n    const variants =\r\n        ensureUniqueNames(variantsDef.map((v: {name: string}) => v.name));\r\n\r\n    for (const scene of gltf.scenes) {\r\n      // Save the variants data under associated mesh.userData\r\n      scene.traverse(object => {\r\n        // The following code can be simplified if parser.associations directly\r\n        // supports meshes.\r\n        const association = parser.associations.get(object);\r\n\r\n        if (!association || association.type !== 'nodes') {\r\n          return;\r\n        }\r\n\r\n        const nodeDef = json.nodes[association.index];\r\n        const meshIndex = nodeDef.mesh;\r\n\r\n        if (meshIndex === undefined) {\r\n          return;\r\n        }\r\n\r\n        // Two limitations:\r\n        // 1. The nodeDef shouldn't have any objects (camera, light, or\r\n        // nodeDef.extensions object)\r\n        //    other than nodeDef.mesh\r\n        // 2. Other plugins shouldn't change any scene graph hierarchy\r\n        // The following code can cause error if hitting the either or both\r\n        // limitations If parser.associations will directly supports meshes\r\n        // these limitations can be removed\r\n\r\n        const meshDef = json.meshes[meshIndex];\r\n        const primitivesDef = meshDef.primitives;\r\n        const meshes = 'isMesh' in object ? [object] : object.children;\r\n\r\n        for (let i = 0; i < primitivesDef.length; i++) {\r\n          const primitiveDef = primitivesDef[i];\r\n          const extensionsDef = primitiveDef.extensions;\r\n          if (!extensionsDef || !extensionsDef[this.name]) {\r\n            continue;\r\n          }\r\n          meshes[i].userData.variantMaterials =\r\n              mappingsArrayToTable(extensionsDef[this.name], variants);\r\n        }\r\n      });\r\n    }\r\n\r\n    gltf.userData.variants = variants;\r\n\r\n    // @TODO: Adding functions to userData might be problematic\r\n    //        for example when serializing?\r\n    gltf.userData.functions = gltf.userData.functions || {};\r\n\r\n    /**\r\n     * @param object {THREE.Mesh}\r\n     * @param variantName {string|null}\r\n     * @return {Promise}\r\n     * @TODO: Support multi materials?\r\n     */\r\n    const switchMaterial = async (\r\n        object: Mesh,\r\n        variantName: string|null,\r\n        onUpdate:\r\n            ((object: Mesh,\r\n              oldMaterial: Material,\r\n              gltfMaterialIndex: number|null) => void)|null) => {\r\n      if (!object.userData.originalMaterial) {\r\n        object.userData.originalMaterial = object.material;\r\n      }\r\n\r\n      const oldMaterial = object.material;\r\n      let gltfMaterialIndex = null;\r\n\r\n      if (variantName === null ||\r\n          !object.userData.variantMaterials.has(variantName)) {\r\n        object.material = object.userData.originalMaterial;\r\n        if (parser.associations.has(object.material as Material)) {\r\n          gltfMaterialIndex =\r\n              parser.associations.get(object.material as Material)!.index;\r\n        }\r\n      } else {\r\n        const variantMaterialParam =\r\n            object.userData.variantMaterials.get(variantName);\r\n\r\n        if (variantMaterialParam.material) {\r\n          object.material = variantMaterialParam.material;\r\n          if ('gltfMaterialIndex' in variantMaterialParam) {\r\n            gltfMaterialIndex = variantMaterialParam.gltfMaterialIndex;\r\n          }\r\n        } else {\r\n          gltfMaterialIndex = variantMaterialParam.gltfMaterialIndex;\r\n          object.material =\r\n              await parser.getDependency('material', gltfMaterialIndex);\r\n          parser.assignFinalMaterial(object);\r\n          variantMaterialParam.material = object.material;\r\n        }\r\n      }\r\n\r\n      if (onUpdate !== null) {\r\n        onUpdate(object, oldMaterial as Material, gltfMaterialIndex);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * @param object {THREE.Mesh}\r\n     * @return {Promise}\r\n     */\r\n    const ensureLoadVariants = (object: Mesh) => {\r\n      const currentMaterial = object.material;\r\n      const variantMaterials = object.userData.variantMaterials;\r\n      const pending = [];\r\n      for (const variantName of variantMaterials.keys()) {\r\n        const variantMaterial = variantMaterials.get(variantName);\r\n        if (variantMaterial.material) {\r\n          continue;\r\n        }\r\n        const materialIndex = variantMaterial.gltfMaterialIndex;\r\n        pending.push(parser.getDependency('material', materialIndex)\r\n                         .then((material: Material) => {\r\n                           object.material = material;\r\n                           parser.assignFinalMaterial(object);\r\n                           variantMaterials.get(variantName).material =\r\n                               object.material;\r\n                         }));\r\n      }\r\n      return Promise.all(pending).then(() => {\r\n        object.material = currentMaterial;\r\n      });\r\n    };\r\n\r\n    /**\r\n     * @param object {THREE.Object3D}\r\n     * @param variantName {string|null}\r\n     * @param doTraverse {boolean} Default is true\r\n     * @param onUpdate {function}\r\n     * @return {Promise}\r\n     */\r\n    gltf.userData.functions.selectVariant =\r\n        (object: Object3D,\r\n         variantName: string|null,\r\n         doTraverse = true,\r\n         onUpdate = null) => {\r\n          const pending = [];\r\n          if (doTraverse) {\r\n            object.traverse(\r\n                (o: Object3D) => compatibleObject(o) &&\r\n                    pending.push(\r\n                        switchMaterial(o as Mesh, variantName, onUpdate)));\r\n          } else {\r\n            compatibleObject(object) &&\r\n                pending.push(\r\n                    switchMaterial(object as Mesh, variantName, onUpdate));\r\n          }\r\n          return Promise.all(pending);\r\n        };\r\n\r\n    /**\r\n     * @param object {THREE.Object3D}\r\n     * @param doTraverse {boolean} Default is true\r\n     * @return {Promise}\r\n     */\r\n    gltf.userData.functions.ensureLoadVariants =\r\n        (object: Object3D, doTraverse = true) => {\r\n          const pending = [];\r\n          if (doTraverse) {\r\n            object.traverse(\r\n                (o: Object3D) => compatibleObject(o) &&\r\n                    pending.push(ensureLoadVariants(o as Mesh)));\r\n          } else {\r\n            compatibleObject(object) &&\r\n                pending.push(ensureLoadVariants(object as Mesh));\r\n          }\r\n          return Promise.all(pending);\r\n        };\r\n\r\n    return Promise.resolve();\r\n  }\r\n}\r\n"]}